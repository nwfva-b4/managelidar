% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_multitemporal.R
\name{filter_multitemporal}
\alias{filter_multitemporal}
\title{Filter tiles by number of temporal observations}
\usage{
filter_multitemporal(
  path,
  n = NULL,
  entire_tiles = TRUE,
  tolerance = 1,
  verbose = TRUE
)
}
\arguments{
\item{path}{Character vector of input paths, a VPC file path, or a VPC object
already loaded in R. Can be a mix of LAS/LAZ/COPC files and \code{.vpc} files.}

\item{n}{Numeric or NULL. Number of observations to filter by:
\itemize{
\item NULL (default): Returns all tiles with 2 or more observations (multi-temporal)
\item 1: Returns tiles with exactly 1 observation (mono-temporal)
\item 2, 3, etc.: Returns tiles with exactly that many observations
}}

\item{entire_tiles}{Logical. If TRUE (default), only considers tiles that are exactly 1000x1000 m
and aligned to a 1000m grid.}

\item{tolerance}{Numeric. Tolerance in coordinate units for snapping extents to grid
(default: 1, submeter inaccuracies are ignored). If > 0, coordinates within this distance of a grid line will be
snapped before processing. Set to 0 to disable snapping.}

\item{verbose}{Logical. If TRUE (default), prints information about filtering results.}
}
\value{
A VPC object (list) containing only tiles matching the temporal criteria.
Returns NULL invisibly if no matching tiles are found.
}
\description{
Filters tiles based on the number of temporal observations, returning a VPC with
tiles that have a specific number of files or multiple observations.
}
\details{
This function identifies tiles based on their temporal coverage. It reads extent and
date information from a VPC (Virtual Point Cloud) file, optionally snaps coordinates
to a regular grid, and groups observations by spatial extent.

When \code{entire_tiles = TRUE}, only tiles that are exactly 1000x1000 m and
aligned to a 1000 m grid are included in the analysis.

When \code{tolerance > 0}, coordinates within that distance of a grid line are
snapped to handle minor floating point inaccuracies.

\strong{When n = NULL (multi-temporal):}

The returned VPC contains \emph{all} observations for multi-temporal
tiles, meaning multiple files may reference the same spatial tile. This is typically
not suitable for direct processing in most workflows in lasR, as data will be processed together.
E.g. creating a Canopy Height Model based on multi-temporal VPCs will result in a single CHM raster based on
lidar data from all acquisitions instead of a separate CHM raster for each acquisition time.

Usually you want to use \code{\link{filter_first}} or \code{\link{filter_latest}} instead.

This intermediate filtering step might be useful when you need to:
\itemize{
\item Identify which tiles have multi-temporal data before selecting a time period
\item Filter to tiles with exactly n observations for quality control
\item Explicitly want to work with combined multi-temporal data
\item Isolate mono-temporal tiles (n = 1) for separate processing
}
}
\examples{
f <- system.file("extdata", package = "managelidar")

# Get all multi-temporal (2+ observations) tiles (entire tiles only, with 10m tolerance)
vpc_multi <- filter_multitemporal(f, tolerance = 10)

# Get only mono-temporal (exactly 1 observation) tiles  (entire tiles only, with 10m tolerance)
vpc_mono <- filter_multitemporal(f, entire_tiles = FALSE, tolerance = 10, n = 1)

# Get tiles with exactly 3 observations (entire tiles only, with 10m tolerance)
vpc_three <- filter_multitemporal(f, n = 3)

# Chain filters for specific workflows:
vpc <- f |>
  filter_multitemporal(tolerance = 10) |>
  filter_temporal("2024") |>
  filter_latest(tolerance = 10)

}
\seealso{
\code{\link{filter_first}}, \code{\link{filter_latest}},
\code{\link{filter_spatial}}, \code{\link{resolve_vpc}}, \code{\link{is_multitemporal}}
}
